# Builtin

There are several builtin classes / methods in lpp.

## Content

- [Builtin](#builtin)
  - [Content](#content)
  - [`Function`](#function)
  - [`Promise`](#promise)
  - [`JSON`](#json)

---

<table>
<tr><td>

## `Function`

lpp supports lambda functions and it is called `Function` instances.

Here is the definition of `Function` class.

```typescript
declare class Function {
  /**
   * @constructor Construct a function using new / without new.
   * @param fn The function.
   * @throws {IllegalInvocationError} If fn is not a function.
   */
  constructor(fn: Function)
  /**
   * Apply the function with specified self object and arguments.
   * @param self Self argument.
   * @param args Arguments.
   * @returns Function result.
   * @throws {IllegalInvocationError} If self is not a function.
   */
  apply(self: any, args: any[]): any
  /**
   * Deserialize a function from object.
   * @param obj The object to deserialize.
   * @returns The deserialized function.
   * @throws {SyntaxError} If fn's format is not correct.
   * @throws {IllegalInvocationError} If self !== Function.
   * @warning This method is not included in lpp core and its behavior is dependent on the platform's implementation.
   */
  static deserialize(obj: object): Function
  /**
   * Serialize a function (that is generated by platform) to object.
   * @param fn The function to serialize.
   * @returns The serialized object.
   * @throws {IllegalInvocationError} If self !== Function or fn is not generated by platform.
   * @warning This method is not included in lpp core and its behavior is dependent on the platform's implementation.
   */
  static serialize(fn: Function): object
}
```

</td></tr>

<tr><td>

## `Promise`

`Promise` is a class for asynchronous programming.

Here is the definition of `Promise` class.

```typescript
interface PromiseLike<T> {
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onFulfilled The callback to execute when the Promise is resolved.
   * @param onRejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
    onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>
  ): PromiseLike<TResult1 | TResult2>
}
/**
 * Recursively unwraps the "awaited type" of a type. Non-promise "thenables" should resolve to `never`. This emulates the behavior of `await`.
 */
type Awaited<T> = T extends null
  ? T // special case for `null | undefined` when not in `--strictNullChecks` mode
  : T extends object & { then(onfulfilled: infer F, ...args: infer _): any } // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped
    ? F extends (value: infer V, ...args: infer _) => any // if the argument to `then` is callable, extracts the first argument
      ? Awaited<V> // recursively unwrap the value
      : never // the argument to `then` was not callable
    : T // non-object or non-thenable
declare class Promise<T> implements PromiseLike<T> {
  /**
   * @constructor Construct a Promise instance.
   * @param executor Executor.
   */
  constructor(
    executor: (
      resolve: (value: T | PromiseLike<T>) => void,
      reject: (reason?: any) => void
    ) => void
  )
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onFulfilled The callback to execute when the Promise is resolved.
   * @param onRejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
    onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>
  ): Promise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onRejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onRejected?: (reason: any) => TResult | PromiseLike<TResult>
  ): Promise<T | TResult>
  /**
   * Creates a new rejected promise for the provided reason.
   * @param reason The reason the promise was rejected.
   * @returns A new rejected Promise.
   */
  static reject<T = never>(reason?: any): Promise<T>
  /**
   * Creates a new resolved promise.
   * @returns A resolved promise.
   */
  static resolve(): Promise<void>
  /**
   * Creates a new resolved promise for the provided value.
   * @param value A promise.
   * @returns A promise whose internal state matches the provided promise.
   */
  static resolve<T>(value: T): Promise<Awaited<T>>
  /**
   * Creates a new resolved promise for the provided value.
   * @param value A promise.
   * @returns A promise whose internal state matches the provided promise.
   */
  static resolve<T>(value: T | PromiseLike<T>): Promise<Awaited<T>>
}
```

</td></tr>

<tr><td>

## `JSON`

`JSON` is a utility set for JSON serialization / deserialization.

Here is the definition of `JSON` namespace.

```typescript
declare namespace JSON {
  /**
   * Parse JSON string as lpp object.
   * @param json JSON string.
   * @returns Parsed lpp object.
   * @throws {IllegalInvocationError} If self is not JSON namespace.
   * @throws {SyntaxError} If json is not specified, or if JSON is invalid.
   */
  function parse(json: string): any
  /**
   * Convert value into JSON string.
   * @param value lpp object.
   * @returns JSON string.
   * @throws {IllegalInvocationError} If self is not JSON namespace.
   * @throws {SyntaxError} If value is not specified, or value is invalid (such as recursive objects, etc.).
   */
  function stringify(value: any): string
}
```

</td></tr>
</table>
